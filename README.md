## Лабораторная работа №3

Для начала необходимо выбрать CI/CD платфому. Выбор пал на Jenkins, так как есть опыт взаимодейсвтия с данной платформой.

В репозитории два варианта пайплайна:
- `Jenkinsfile.bad` — намеренно «плохой», но рабочий пример
- `Jenkinsfile.good` — улучшенный вариант с исправлениями и добавлениями "best practices"


### 1) Подготовка Jenkins проекта
- Разверните Jenkins локально. Самый простой способ – использовать Docker и готовый образ для Jenkins master node. (Пример из использованного docker-compose.yml)
```yml
  jenkins:
    image: jenkins/jenkins:lts-jdk17
    container_name: jenkins
    restart: unless-stopped
    ports:
      - "8080:8080"   # Jenkins web UI
      - "50000:50000" # Inbound agent port
    volumes:
      - jenkins_data:/var/jenkins_home
    healthcheck:
      test: ["CMD-SHELL", "curl -sS -L http://localhost:8080/login >/dev/null 2>&1"]
      interval: 10s
      timeout: 5s
      retries: 30
      start_period: 30s
```
- Создайте одного агента. (Jenkins имеет очень хорошую документацию: https://www.jenkins.io/doc/book/using/using-agents/)
- Создайте Pipeline из SCM.
- Укажите путь к Jenkinsfile.
- Создайте креды `artifactory-credentials` (Username + Password) — имитируем приватный реестр/репозиторий артефактов для шага «Deploy».

### 2) Разбор «плохого» пайплайна
Основные проблемы `Jenkinsfile.bad`:
1. **Именование агнета по его назначению**: такие агенты неудобно переиспользовать, так как не понятно, что находится "под капотом". Такой варинант именования можно использовать, если устройство агента излишне специфическое. Но когда агент достаточно универсальный, лучше описать это кратко в лейблах. (Например, `docker && x86_64`, `python && ansible && x86_64`).
2. **Хардкод секретов и их логирование**: в Jenkins есть встроенная функция хранения секретов. Также при необходимости можно воспользоваться внешними инструменатми, например, `vault`.
3. **Нет `checkout scm`**: сборка может быть достаточно нестабильной из-за мусора в workspace. Лучше использовать подход "с чистого листа" для универсальности.
4. **`curl | sh`**: исполнение удалённого кода без проверки и версионирования.
5. **Docker `:latest`**: использование тегов, которые не указывают точную версию может привести к тому, что код протестирует иной коммит, в CI это можно легко упустить и занести трудно определяемую ошибку.
6. **Нет таймаутов/ограничений конкурентности**: может привести к зависаниям, простою ресурсов и накладладкам.
7. **Нет cleanup**: воркспейс зарастает мусором.


### 3) «Хороший» пайплайн
`Jenkinsfile.good`:
1. **Агент по лейблам**: `node('opensuse && x86_64')` — используется универсальный агент.
2. **Ограничение конкуренции и таймаут**: `disableConcurrentBuilds()`, `timeout(...)`.
3. **Явный `checkout scm`**: чистая и повторяемая сборка.
4. **Docker Pipeline API**: `docker.build(...)` и `.inside { ... }` вместо прямого `docker ...`. Использование модулей вместо прямого использования `sh` скриптов – отличное решение, которое может избавить от ненужного кода, и является более корректным способом для работы со сторонними инстурментами.
5. **Иммутабельный тег образа**: тег из `git rev-parse --short HEAD`.
6. **Credentials вместо хардкода**: `withCredentials([usernamePassword(credentialsId: 'artifactory-credentials', ...)])`. (Интересный факт: получить значение секретов мы не можем напрямую в Jenkins UI или файловой системе, но обходные пути есть...)
7. **Cleanup**: `cleanWs()` в `finally`.
8. **Декомпозиция**: использование stages для разделение пайплайна на логические части.